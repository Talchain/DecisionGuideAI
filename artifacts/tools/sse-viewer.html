<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Sandbox SSE Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        .header h1 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .control-group h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .form-row {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-weight: bold;
        }

        input, select {
            width: 100%;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: monospace;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .btn-secondary {
            background: #555;
            color: white;
        }

        .btn-secondary:hover {
            background: #666;
        }

        .btn-warning {
            background: #ff9800;
            color: white;
        }

        .btn-warning:hover {
            background: #e68900;
        }

        .btn-test {
            background: #9c27b0;
            color: white;
        }

        .btn-test:hover {
            background: #7b1fa2;
        }

        .resilience-controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-bottom: 20px;
        }

        .resilience-controls h3 {
            color: #9c27b0;
            margin-bottom: 15px;
        }

        .test-badges {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .badge {
            padding: 5px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .badge-pass {
            background: #4caf50;
            color: white;
        }

        .badge-fail {
            background: #f44336;
            color: white;
        }

        .badge-pending {
            background: #ff9800;
            color: white;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 24px;
            background: #555;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle.active {
            background: #9c27b0;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle.active::after {
            transform: translateX(26px);
        }

        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 4px;
            font-weight: bold;
        }

        .status-disconnected {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #e57373;
        }

        .status-connected {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #4caf50;
        }

        .status-error {
            background: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ff9800;
        }

        .log-container {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-header {
            background: #333;
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            color: #4CAF50;
            font-weight: bold;
            position: sticky;
            top: 0;
        }

        .log-content {
            padding: 15px;
        }

        .log-entry {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #555;
        }

        .log-start {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .log-token {
            border-left-color: #2196F3;
            background: rgba(33, 150, 243, 0.1);
        }

        .log-done {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .log-cancelled {
            border-left-color: #FF9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .log-error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        .log-info {
            border-left-color: #9C27B0;
            background: rgba(156, 39, 176, 0.1);
        }

        .timestamp {
            color: #888;
            font-size: 11px;
        }

        .metadata {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .metadata-item {
            background: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .metadata-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .metadata-value {
            color: #4CAF50;
            font-family: monospace;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Scenario Sandbox SSE Viewer</h1>
            <p>Zero-friction validation tool for Windsurf live-swap integration</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üîå Connection Settings</h3>
                <div class="form-row">
                    <label for="baseUrl">Base URL:</label>
                    <input type="text" id="baseUrl" value="http://localhost:3001" placeholder="http://localhost:3001">
                </div>
                <div class="form-row">
                    <label for="route">Route:</label>
                    <select id="route">
                        <option value="critique">critique</option>
                        <option value="analysis">analysis</option>
                        <option value="decision">decision</option>
                    </select>
                </div>
                <div class="form-row">
                    <label for="sessionId">Session ID:</label>
                    <input type="text" id="sessionId" value="" placeholder="Auto-generated">
                </div>
            </div>

            <div class="control-group">
                <h3>‚öôÔ∏è Parameters</h3>
                <div class="form-row">
                    <label for="seed">Seed:</label>
                    <input type="number" id="seed" value="42" placeholder="42">
                </div>
                <div class="form-row">
                    <label for="budget">Budget:</label>
                    <input type="number" id="budget" value="1000" placeholder="1000">
                </div>
                <div class="form-row">
                    <label for="lastEventId">Last-Event-ID (Resume):</label>
                    <input type="text" id="lastEventId" value="" placeholder="Leave empty for new connection">
                </div>
            </div>
        </div>

        <div class="resilience-controls">
            <h3>üß™ Resilience Testing</h3>
            <div class="toggle-container">
                <div class="toggle" id="networkBlipToggle" onclick="toggleNetworkBlip()"></div>
                <label>Simulate network blip (auto-resume test)</label>
            </div>
            <div class="buttons">
                <button class="btn-test" onclick="cancelTwice()">üîÑ Cancel Twice</button>
                <button class="btn-test" onclick="runResilienceTest()">üß™ Run Full Test</button>
            </div>
            <div class="test-badges">
                <span class="badge badge-pending" id="firstTokenBadge">First token under budget</span>
                <span class="badge badge-pending" id="singleResumeBadge">Single resume occurred</span>
                <span class="badge badge-pending" id="cancelIdempotentBadge">Cancel idempotent</span>
            </div>
        </div>

        <div class="buttons">
            <button class="btn-primary" onclick="connect()">üîå Connect</button>
            <button class="btn-danger" onclick="cancel()">‚èπÔ∏è Cancel</button>
            <button class="btn-warning" onclick="resume()">üîÑ Resume</button>
            <button class="btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
            <button class="btn-secondary" onclick="testReport()">üìã Test Report</button>
        </div>

        <div id="status" class="status status-disconnected">
            ‚ùå Disconnected - Ready to connect
        </div>

        <div class="log-container">
            <div class="log-header">
                üì° Live SSE Events Log
            </div>
            <div class="log-content" id="logContent">
                <div class="log-entry log-info">
                    <div class="timestamp">[Ready]</div>
                    <div>SSE Viewer ready. Click Connect to start streaming events.</div>
                </div>
            </div>
        </div>

        <div class="metadata">
            <div class="metadata-item">
                <div class="metadata-label">Connection State</div>
                <div class="metadata-value" id="connectionState">DISCONNECTED</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Events Received</div>
                <div class="metadata-value" id="eventCount">0</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Last Event ID</div>
                <div class="metadata-value" id="lastEventIdDisplay">-</div>
            </div>
            <div class="metadata-item">
                <div class="metadata-label">Session</div>
                <div class="metadata-value" id="currentSession">-</div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let eventCount = 0;
        let currentSessionId = null;
        let lastReceivedEventId = null;
        let networkBlipEnabled = false;
        let hasReceivedFirstToken = false;
        let resumeCount = 0;
        let cancelCount = 0;
        let connectionStartTime = null;

        function generateSessionId() {
            return 'viewer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status status-' + type;
        }

        function updateMetadata() {
            document.getElementById('connectionState').textContent = eventSource ? 'CONNECTED' : 'DISCONNECTED';
            document.getElementById('eventCount').textContent = eventCount;
            document.getElementById('lastEventIdDisplay').textContent = lastReceivedEventId || '-';
            document.getElementById('currentSession').textContent = currentSessionId || '-';
        }

        function addLogEntry(type, content, data = null) {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = 'log-entry log-' + type;

            const timestamp = new Date().toISOString();
            entry.innerHTML = `
                <div class="timestamp">[${timestamp}]</div>
                <div>${content}</div>
                ${data ? `<div style="margin-top: 5px; color: #ccc; font-size: 11px;">${JSON.stringify(data, null, 2)}</div>` : ''}
            `;

            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
            eventCount++;
            updateMetadata();
        }

        function connect() {
            if (eventSource) {
                eventSource.close();
            }

            const baseUrl = document.getElementById('baseUrl').value;
            const route = document.getElementById('route').value;
            let sessionId = document.getElementById('sessionId').value;
            const seed = document.getElementById('seed').value;
            const budget = document.getElementById('budget').value;
            const lastEventId = document.getElementById('lastEventId').value;

            if (!sessionId) {
                sessionId = generateSessionId();
                document.getElementById('sessionId').value = sessionId;
            }

            currentSessionId = sessionId;
            connectionStartTime = Date.now();

            const url = new URL('/stream', baseUrl);
            url.searchParams.set('route', route);
            url.searchParams.set('sessionId', sessionId);
            if (seed) url.searchParams.set('seed', seed);
            if (budget) url.searchParams.set('budget', budget);

            addLogEntry('info', `Connecting to: ${url.toString()}`);

            const eventSourceOptions = {};
            if (lastEventId) {
                eventSourceOptions.headers = { 'Last-Event-ID': lastEventId };
                addLogEntry('info', `Using Last-Event-ID: ${lastEventId}`);
            }

            eventSource = new EventSource(url.toString());

            eventSource.onopen = function() {
                updateStatus('üü¢ Connected - Streaming events', 'connected');
                addLogEntry('info', 'SSE connection opened');
                updateMetadata();
            };

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);

                    // Track event ID if present
                    if (event.lastEventId) {
                        lastReceivedEventId = event.lastEventId;
                        document.getElementById('lastEventId').value = event.lastEventId;
                    }

                    // Determine event type and handle accordingly
                    let logType = 'info';
                    let logMessage = 'Unknown event';

                    if (data.type) {
                        switch (data.type) {
                            case 'start':
                                logType = 'start';
                                logMessage = `üöÄ Stream started (session: ${data.sessionId || sessionId})`;
                                break;
                            case 'token':
                                logType = 'token';
                                logMessage = `üí¨ Token: "${data.text}" (index: ${data.tokenIndex || 'unknown'})`;

                                // Check first token timing for badge test
                                if (!hasReceivedFirstToken) {
                                    hasReceivedFirstToken = true;
                                    const elapsed = Date.now() - connectionStartTime;
                                    const budget = parseInt(document.getElementById('budget').value) || 1000;

                                    if (elapsed <= budget) {
                                        updateBadge('firstTokenBadge', 'pass');
                                        addLogEntry('info', `‚úÖ First token in ${elapsed}ms (under ${budget}ms budget)`);
                                    } else {
                                        updateBadge('firstTokenBadge', 'fail');
                                        addLogEntry('error', `‚ùå First token in ${elapsed}ms (over ${budget}ms budget)`);
                                    }
                                }

                                // Simulate network blip if enabled
                                if (networkBlipEnabled && !lastEventId && Math.random() < 0.3) {
                                    addLogEntry('info', 'üåê Simulating network blip...');
                                    setTimeout(() => {
                                        eventSource.close();
                                        setTimeout(() => {
                                            addLogEntry('info', 'üîÑ Auto-resuming after blip...');
                                            resume();
                                        }, 800 + Math.random() * 400); // 800-1200ms delay
                                    }, 100);
                                }
                                break;
                            case 'done':
                                logType = 'done';
                                logMessage = `‚úÖ Stream completed (total tokens: ${data.totalTokens || 'unknown'})`;
                                break;
                            case 'cancelled':
                                logType = 'cancelled';
                                logMessage = `‚èπÔ∏è Stream cancelled (reason: ${data.reason || 'user request'})`;
                                break;
                            case 'error':
                                logType = 'error';
                                logMessage = `‚ùå Error: ${data.message || 'Unknown error'}`;
                                break;
                            case 'progress':
                                logType = 'token';
                                logMessage = `üìä Progress: ${data.percent || 0}% - ${data.message || ''}`;
                                break;
                            default:
                                logType = 'info';
                                logMessage = `üì° Event: ${data.type}`;
                        }
                    } else {
                        logMessage = 'üì° Raw event data';
                    }

                    addLogEntry(logType, logMessage, data);
                    updateMetadata();

                } catch (e) {
                    addLogEntry('error', 'Failed to parse event data: ' + e.message, { raw: event.data });
                }
            };

            eventSource.onerror = function(event) {
                updateStatus('‚ùå Connection error - Check server status', 'error');
                addLogEntry('error', 'SSE connection error', { readyState: eventSource.readyState });
                updateMetadata();
            };
        }

        function cancel() {
            if (!currentSessionId) {
                addLogEntry('error', 'No active session to cancel');
                return;
            }

            const baseUrl = document.getElementById('baseUrl').value;

            fetch(baseUrl + '/cancel', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ sessionId: currentSessionId })
            })
            .then(response => {
                addLogEntry('info', `Cancel request sent - HTTP ${response.status}`, {
                    status: response.status,
                    statusText: response.statusText
                });
                return response.json();
            })
            .then(data => {
                addLogEntry('info', 'Cancel response received', data);
            })
            .catch(error => {
                addLogEntry('error', 'Cancel request failed: ' + error.message);
            });
        }

        function resume() {
            if (!lastReceivedEventId) {
                addLogEntry('error', 'No Last-Event-ID available for resume');
                return;
            }

            resumeCount++;
            if (resumeCount === 1) {
                updateBadge('singleResumeBadge', 'pass');
                addLogEntry('info', '‚úÖ Single resume test passed');
            } else if (resumeCount > 1) {
                updateBadge('singleResumeBadge', 'fail');
                addLogEntry('error', `‚ùå Multiple resumes detected (${resumeCount})`);
            }

            document.getElementById('lastEventId').value = lastReceivedEventId;
            addLogEntry('info', `Resuming from Last-Event-ID: ${lastReceivedEventId}`);
            connect();
        }

        function clearLog() {
            document.getElementById('logContent').innerHTML = `
                <div class="log-entry log-info">
                    <div class="timestamp">[${new Date().toISOString()}]</div>
                    <div>Log cleared</div>
                </div>
            `;
            eventCount = 0;
            updateMetadata();
        }

        function testReport() {
            const baseUrl = document.getElementById('baseUrl').value;
            const seed = document.getElementById('seed').value;

            const url = new URL('/report', baseUrl);
            url.searchParams.set('scenarioId', 'demo');
            if (seed) url.searchParams.set('seed', seed);

            addLogEntry('info', `Testing report endpoint: ${url.toString()}`);

            fetch(url.toString())
            .then(response => {
                addLogEntry('info', `Report response - HTTP ${response.status}`, {
                    status: response.status,
                    headers: Object.fromEntries(response.headers.entries())
                });
                return response.json();
            })
            .then(data => {
                addLogEntry('info', 'Report data received', data);
            })
            .catch(error => {
                addLogEntry('error', 'Report request failed: ' + error.message);
            });
        }

        // Initialize
        updateMetadata();

        // Auto-generate session ID on load
        document.getElementById('sessionId').value = generateSessionId();

        // Resilience testing functions
        function updateBadge(badgeId, status) {
            const badge = document.getElementById(badgeId);
            badge.className = `badge badge-${status}`;
        }

        function toggleNetworkBlip() {
            networkBlipEnabled = !networkBlipEnabled;
            const toggle = document.getElementById('networkBlipToggle');
            toggle.classList.toggle('active', networkBlipEnabled);
            addLogEntry('info', `Network blip simulation ${networkBlipEnabled ? 'enabled' : 'disabled'}`);
        }

        function cancelTwice() {
            if (!currentSessionId) {
                addLogEntry('error', 'No active session to test cancel');
                return;
            }

            addLogEntry('info', 'üß™ Testing cancel idempotence...');

            // First cancel
            fetch(document.getElementById('baseUrl').value + '/cancel', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId: currentSessionId })
            })
            .then(response => {
                addLogEntry('info', `First cancel: HTTP ${response.status}`);
                const firstStatus = response.status;

                // Second cancel immediately
                return fetch(document.getElementById('baseUrl').value + '/cancel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: currentSessionId })
                }).then(secondResponse => {
                    addLogEntry('info', `Second cancel: HTTP ${secondResponse.status}`);

                    // Check idempotence: 202 -> 409
                    if (firstStatus === 202 && secondResponse.status === 409) {
                        updateBadge('cancelIdempotentBadge', 'pass');
                        addLogEntry('info', '‚úÖ Cancel idempotence test passed (202 ‚Üí 409)');
                    } else {
                        updateBadge('cancelIdempotentBadge', 'fail');
                        addLogEntry('error', `‚ùå Expected 202 ‚Üí 409, got ${firstStatus} ‚Üí ${secondResponse.status}`);
                    }
                });
            })
            .catch(error => {
                addLogEntry('error', 'Cancel test failed: ' + error.message);
                updateBadge('cancelIdempotentBadge', 'fail');
            });
        }

        function runResilienceTest() {
            addLogEntry('info', 'üß™ Starting full resilience test suite...');

            // Reset all badges
            updateBadge('firstTokenBadge', 'pending');
            updateBadge('singleResumeBadge', 'pending');
            updateBadge('cancelIdempotentBadge', 'pending');

            // Reset counters
            hasReceivedFirstToken = false;
            resumeCount = 0;
            cancelCount = 0;

            // Enable network blip simulation
            if (!networkBlipEnabled) {
                toggleNetworkBlip();
            }

            // Start connection
            connect();

            // Schedule cancel test after a delay
            setTimeout(() => {
                if (currentSessionId) {
                    cancelTwice();
                }
            }, 3000);
        }

        function resetTests() {
            updateBadge('firstTokenBadge', 'pending');
            updateBadge('singleResumeBadge', 'pending');
            updateBadge('cancelIdempotentBadge', 'pending');
            hasReceivedFirstToken = false;
            resumeCount = 0;
            cancelCount = 0;
        }
    </script>
</body>
</html>